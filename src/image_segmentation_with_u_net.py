# -*- coding: utf-8 -*-
"""Image Segmentation with U-Net.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TL5K0G4pWw0UBjS7o7sOYY7awc20_41O

# UNet Implementation

This notebook contains a PyTorch implementation of the UNet architecture, a convolutional neural network designed for biomedical image segmentation.

## Architecture

The UNet consists of a contracting path (encoder) and an expansive path (decoder).

- **Contracting Path:** Repeatedly applies two 3x3 convolutions followed by a 2x2 max pooling operation.
- **Expansive Path:** Consists of an upsampling of the feature map followed by a 2x2 convolution, a concatenation with the feature map from the corresponding cropped layer in the contracting path, and two 3x3 convolutions.
- **Final Layer:** A 1x1 convolution is used to map the feature vectors to the desired number of classes.

## Code Structure

The implementation is organized into the following classes and functions:

- `conv3x3`: Helper function for a 3x3 convolutional layer.
- `upconv2x2`: Helper function for a 2x2 up-convolutional layer (or upsampling and 1x1 convolution).
- `conv1x1`: Helper function for a 1x1 convolutional layer.
- `DownConv`: Implements a block in the contracting path.
- `upConv`: Implements a block in the expansive path.
- `UNet`: The main UNet model class.

## Usage

The `UNet` class can be instantiated with the number of input channels and the number of output classes.
"""


from math import atan2, cos, sin, sqrt, pi, log

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch import  nn
from torchinfo import summary

def conv3x3(in_channels, out_channels, stride=1, padding=1, bias=True, groups=1):
  return nn.Conv3d(in_channels, out_channels, kernel_size =3, stride=stride,padding=padding, bias=bias, groups=groups )

def upconv2x2(in_channels, out_channels, mode='transpose'):
  if mode == 'transpose':
    return nn.ConvTranspose3d(in_channels,out_channels,kernel_size=2, stride=2)
  else:
    return nn.Sequential( nn.Upsample(mode='trilinear',scale_factor=2,align_corners=False), conv1x1(in_channels,out_channels))

def conv1x1(in_channels, out_channels, groups=1):
  return nn.Conv3d(in_channels, out_channels, kernel_size=1, groups=groups, stride=1)

class DownConv(nn.Module):
  def __init__(self, in_channel, out_channel, pooling=True):
    super(DownConv, self).__init__()
    self.in_channel=in_channel
    self.out_channel=out_channel
    self.pooling = pooling

    self.conv1 = conv3x3(self.in_channel, self.out_channel)
    self.conv2 = conv3x3(self.out_channel, self.out_channel)

  def forward(self, x):

    x = F.relu(self.conv1(x))
    x = F.relu(self.conv2(x))
    before_pooling = x
    if self.pooling:
      x = F.max_pool3d(x, kernel_size=2, stride=2)
    return x, before_pooling

class upConv(nn.Module):
  def __init__(self, in_channel, out_channel, up_mode='transpose'):
    super(upConv, self).__init__()
    self.in_channel = in_channel
    self.out_channel = out_channel
    self.up_mode = up_mode

    self.upconv = upconv2x2( self.in_channel, self.out_channel, mode= self.up_mode)
    self.conv1 = conv3x3(
            2*self.out_channel, self.out_channel)
    self.conv2 = conv3x3(self.out_channel, self.out_channel)



  def forward(self, from_down, from_up):
    up = self.upconv(from_up)
    x = torch.cat((up, from_down), 1)
    x = F.relu(self.conv1(x))
    x = F.relu(self.conv2(x))
    return x

class UNet(nn.Module):
  """ Unet Architecture """
  def __init__(self, in_channel, class_no):
    super(UNet, self).__init__()
    self.down_convolution_1 = DownConv(in_channel, 16)
    self.down_convolution_2 = DownConv(16, 32)
    self.down_convolution_3 = DownConv(32, 64)
    self.down_convolution_4 = DownConv(64, 128)
    self.bottle_neck = DownConv(128, 256, pooling=False)
    self.up_convolution_1 = upConv(256, 128)
    self.up_convolution_2 = upConv(128, 64)
    self.up_convolution_3 = upConv(64, 32)
    self.up_convolution_4 = upConv(32, 16)
    self.out = conv1x1(16, class_no)

  def forward(self, x):
    x1, before_pooling1 = self.down_convolution_1(x)
    x2, before_pooling2 = self.down_convolution_2(x1)
    x3, before_pooling3 = self.down_convolution_3(x2)
    x4, before_pooling4 = self.down_convolution_4(x3)
    x5, _ = self.bottle_neck(x4)
    up1 = self.up_convolution_1(before_pooling4, x5)
    up2 = self.up_convolution_2(before_pooling3, up1)
    up3 = self.up_convolution_3(before_pooling2, up2)
    up4 = self.up_convolution_4(before_pooling1, up3)
    out = self.out(up4)
    return out

model = UNet(in_channel=3, class_no=4)
summary(model, input_size=(1, 3, 128, 128, 128))

